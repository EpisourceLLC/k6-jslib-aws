{"version":3,"file":"kinesis.js","mappings":"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","sources":["webpack://k6-jslib-aws/webpack/bootstrap","webpack://k6-jslib-aws/webpack/runtime/compat get default export","webpack://k6-jslib-aws/webpack/runtime/define property getters","webpack://k6-jslib-aws/webpack/runtime/hasOwnProperty shorthand","webpack://k6-jslib-aws/webpack/runtime/make namespace object","webpack://k6-jslib-aws/./src/internal/config.ts","webpack://k6-jslib-aws/external commonjs \"k6/crypto\"","webpack://k6-jslib-aws/./src/internal/constants.ts","webpack://k6-jslib-aws/external commonjs \"k6/html\"","webpack://k6-jslib-aws/./src/internal/error.ts","webpack://k6-jslib-aws/./src/internal/signature.ts","webpack://k6-jslib-aws/./src/internal/http.ts","webpack://k6-jslib-aws/./src/internal/utils.ts","webpack://k6-jslib-aws/external commonjs \"k6/http\"","webpack://k6-jslib-aws/./src/internal/kinesis.ts","webpack://k6-jslib-aws/./src/internal/client.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { HTTPScheme } from './http'\n\n/** Class holding an AWS connection information */\nexport class AWSConfig {\n    /**\n     * The AWS region to connect to, as listed: https://docs.aws.amazon.com/general/latest/gr/rande.html\n     *\n     * @type {string}\n     */\n    region: string\n\n    /**\n     * Your user's AWS access key id credential.\n     *\n     * @type {string}\n     */\n    accessKeyId: string\n\n    /**\n     * Your user's AWS secret access key credential.\n     *\n     * @type {string}\n     */\n    secretAccessKey: string\n\n    /**\n     * Your user's AWS session token credential.\n     *\n     * @type {string}\n     */\n    sessionToken?: string\n\n    /**\n     * The HTTP scheme to use when connecting to AWS.\n     *\n     * @type {HTTPScheme} ['https']\n     */\n    scheme: HTTPScheme = 'https'\n\n    // FIXME: Should really be called \"host\" instead. When used\n    // with localstack we pass a complete host (hostname:port) here.\n    /**\n     * The AWS hostname to connect to.\n     *\n     * @type {string} ['amazonaws.com']\n     */\n    endpoint: string = 'amazonaws.com'\n\n    /**\n     * fromEnvironment creates an AWSConfig from the environment variables.\n     *\n     * It expects to find the following compulsory environment variables:\n     *  * AWS_REGION\n     *  * AWS_ACCESS_KEY_ID\n     *  * AWS_SECRET_ACCESS_KEY\n     *\n     * If set, the following optional environment variables are also used:\n     *  * AWS_SESSION_TOKEN\n     *\n     * Finally, the options parameter allows to explicitly set the scheme and endpoint\n     * to use when connecting to AWS.\n     *\n     * @param options {AWSConnectionOptions}\n     * @returns\n     */\n    static fromEnvironment(options?: AWSConnectionOptions): AWSConfig {\n        const region = __ENV.AWS_REGION;\n        const accessKeyId = __ENV.AWS_ACCESS_KEY_ID;\n        const secretAccessKey = __ENV.AWS_SECRET_ACCESS_KEY;\n        const sessionToken: string | undefined = __ENV.AWS_SESSION_TOKEN;\n        const scheme: HTTPScheme | undefined = options?.scheme;\n        const endpoint: string | undefined = options?.endpoint;\n\n        return new AWSConfig({\n            region,\n            accessKeyId,\n            secretAccessKey,\n            sessionToken,\n            scheme: scheme,\n            endpoint: endpoint,\n        })\n    }\n\n    /**\n     * Create an AWSConfig.\n     *\n     * @param {AWSConfigOptions} options - configuration attributes to use when interacting with AWS' APIs\n     * @throws {InvalidArgumentException}\n     */\n    constructor(options: AWSConfigOptions) {\n        if (!options.region || options.region === '') {\n            throw new InvalidAWSConfigError(\n                `invalid AWS region; reason: expected a valid AWS region name (e.g. \"us-east-1\"), got \\`${options.region}\\``\n            )\n        }\n\n        if (!options.accessKeyId || options.accessKeyId === '') {\n            throw new InvalidAWSConfigError(\n                `invalid AWS access key ID; reason: expected a non empty string, got \\`${options.accessKeyId}\\``\n            )\n        }\n\n        if (options.accessKeyId.length < 16 || options.accessKeyId.length > 128) {\n            throw new InvalidAWSConfigError(\n                `invalid AWS access key ID; reason: size should be between 16 and 128 characters, got ${options.accessKeyId.length}`\n            )\n        }\n\n        if (!options.secretAccessKey || options.secretAccessKey === '') {\n            throw new InvalidAWSConfigError(\n                `invalid AWS secret access key; reason: expected a non empty string, got \\`${options.secretAccessKey}\\``\n            )\n        }\n\n        if (options.secretAccessKey.length < 16 || options.secretAccessKey.length > 128) {\n            throw new InvalidAWSConfigError(\n                `invalid AWS secret access key; reason: size should be between 16 and 128 characters, got ${options.secretAccessKey.length}`\n            )\n        }\n\n        this.region = options.region\n        this.accessKeyId = options.accessKeyId\n        this.secretAccessKey = options.secretAccessKey\n\n        if (options.sessionToken !== undefined) {\n            this.sessionToken = options.sessionToken\n        }\n\n        if (options.scheme !== undefined) {\n            this.scheme = options.scheme\n        }\n\n        if (options.endpoint !== undefined) {\n            this.endpoint = options.endpoint\n        }\n    }\n}\n\n/**\n * Interface representing AWSConfig options\n */\nexport interface AWSConfigOptions extends AWSConnectionOptions {\n    /**\n     * The AWS region to connect to, as listed: https://docs.aws.amazon.com/general/latest/gr/rande.html\n     *\n     * @type {string}\n     */\n    region: string\n\n    /**\n     * Your user's AWS access key id credential.\n     *\n     * @type {string}\n     */\n    accessKeyId: string\n\n    /**\n     * Your user's AWS secret access key credential.\n     *\n     * @type {string}\n     */\n    secretAccessKey: string\n\n    /**\n     * Your user's AWS session token credential.\n     *\n     * @type {string}\n     */\n    sessionToken?: string\n}\n\n/**\n * Interface representing AWS connection options\n */\nexport interface AWSConnectionOptions {\n    /**\n     * The HTTP scheme to use when connecting to AWS.\n     *\n     * @type {HTTPScheme}\n     */\n    scheme?: HTTPScheme\n\n    /**\n     * The AWS hostname to connect to.\n     *\n     * @type {string}\n     */\n    endpoint?: string\n}\n\n/** Class representing an invalid AWS configuration */\nexport class InvalidAWSConfigError extends Error {\n    constructor(message: string) {\n        super(message)\n    }\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"k6/crypto\");","/**\n * Standard Amazon AWS query parameter names\n */\nexport const AMZ_ALGORITHM_QUERY_PARAM = 'X-Amz-Algorithm'\nexport const AMZ_CREDENTIAL_QUERY_PARAM = 'X-Amz-Credential'\nexport const AMZ_DATE_QUERY_PARAM = 'X-Amz-Date'\nexport const AMZ_EXPIRES_QUERY_PARAM = 'X-Amz-Expires'\nexport const AMZ_SIGNATURE_QUERY_PARAM = 'X-Amz-Signature'\nexport const AMZ_SIGNED_HEADERS_QUERY_PARAM = 'X-Amz-SignedHeaders'\nexport const AMZ_TARGET_QUERY_PARAM = 'X-Amz-Target'\nexport const AMZ_TOKEN_QUERY_PARAM = 'X-Amz-Security-Token'\n\n/**\n * Standard Amazon AWS header names\n */\nexport const AMZ_CONTENT_SHA256_HEADER = 'x-amz-content-sha256'\nexport const AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase()\nexport const AMZ_SIGNATURE_HEADER = AMZ_SIGNATURE_QUERY_PARAM.toLowerCase()\nexport const AMZ_TARGET_HEADER = AMZ_TARGET_QUERY_PARAM.toLowerCase()\nexport const AMZ_TOKEN_HEADER = AMZ_TOKEN_QUERY_PARAM.toLowerCase()\n\n/**\n * Common HTTP headers we rely on in the signing process\n */\nexport const AUTHORIZATION_HEADER = 'authorization'\nexport const DATE_HEADER = 'date'\n\n/**\n * Lists the headers that are generated as part of the signature process.\n */\nexport const GENERATED_HEADERS = [AUTHORIZATION_HEADER, AMZ_DATE_HEADER, DATE_HEADER]\nexport const HOST_HEADER = 'host'\n\n/**\n * Lists the headers that should never be included in the\n * request signature signature process.\n */\nexport const ALWAYS_UNSIGNABLE_HEADERS = {\n    authorization: true,\n    'cache-control': true,\n    connection: true,\n    expect: true,\n    from: true,\n    'keep-alive': true,\n    'max-forwards': true,\n    pragma: true,\n    referer: true,\n    te: true,\n    trailer: true,\n    'transfer-encoding': true,\n    upgrade: true,\n    'user-agent': true,\n    'x-amzn-trace-id': true,\n}\n\n/**\n * Signature specific constants included in the signing process\n */\nexport const KEY_TYPE_IDENTIFIER = 'aws4_request'\nexport const SIGNING_ALGORITHM_IDENTIFIER = 'AWS4-HMAC-SHA256'\n\n/**\n * Maximum time to live of a signed request in seconds: 7 days.\n */\nexport const MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7\n\n/**\n * SHA256 hash of an empty string (so we don't waste cycles recomputing it)\n */\nexport const EMPTY_SHA256 = 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'\n\n/**\n * SHA256 hash of the unsigned payload constant (so we don't waste cycles recomputing it)\n */\nexport const UNSIGNED_PAYLOAD_SHA256 =\n    '5a41b0751e4537c6ff868564ab44a4d4ecceec2ec5b1c5f74d97422968e04237'\n\nexport const UNSIGNED_PAYLOAD = 'UNSIGNED-PAYLOAD'\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"k6/html\");","import { parseHTML } from 'k6/html'\n\n/**\n * Base class to derive errors from\n *\n * Inspired from AWS official error types, as\n * described in:\n *   * https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/\n *   * https://github.com/aws/aws-sdk-js/blob/master/lib/error.d.ts\n */\nexport class AWSError extends Error {\n    /**\n     * Error code issued by the service (if any)\n     */\n    code?: string\n\n    /**\n     * Create an AWSError\n     *\n     * @param {string} message - A longer human readable error message.\n     * @param {string?} code - A unique short code representing the error that was emitted\n     */\n    constructor(message: string, code?: string) {\n        super(message)\n        this.name = 'AWSError'\n        this.code = code\n    }\n\n    /**\n     * Parse an AWSError from an XML document\n     *\n     * @param  {string} xmlDocument - Serialized XML document to parse the error from\n     */\n    static parseXML(xmlDocument: string): AWSError {\n        const doc = parseHTML(xmlDocument)\n        return new AWSError(doc.find('Message').text(), doc.find('Code').text())\n    }\n}\n","import crypto from 'k6/crypto'\n\nimport * as constants from './constants'\nimport { AWSError } from './error'\nimport { hasHeader, HTTPHeaderBag, HTTPRequest, QueryParameterBag, SignedHTTPRequest } from './http'\nimport { isArrayBuffer } from './utils'\n\n/**\n * SignatureV4 can be used to sign HTTP requests and presign URLs using the AWS Signature\n * Version 4 signing process.\n *\n * It offers two signing methods:\n * - sign: signs the request headers and payload\n * - presign: returns a presigned (authorization information contained in the query string) URL\n *\n * @see https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html\n */\nexport class SignatureV4 {\n    /**\n     * The name of the service to sign for.\n     */\n    private readonly service: string\n\n    /**\n     * The name of the region to sign for.\n     */\n    private readonly region: string\n\n    /**\n     * The credentials with which the request should be signed.\n     */\n    private readonly credentials: Credentials\n\n    /**\n     * Whether to uri-escape the request URI path as part of computing the\n     * canonical request string. This is required for every AWS service, except\n     * Amazon S3, as of late 2017.\n     *\n     * @default [true]\n     */\n    private readonly uriEscapePath: boolean\n\n    /**\n     * Whether to calculate a checksum of the request body and include it as\n     * either a request header (when signing) or as a query string parameter\n     * (when presigning). This is required for AWS Glacier and Amazon S3 and optional for\n     * every other AWS service as of late 2017.\n     *\n     * @default [true]\n     */\n    private readonly applyChecksum: boolean\n\n    // TODO: uriEscapePath and applyChecksum should not be present in the constructor\n    constructor({\n        service,\n        region,\n        credentials,\n        uriEscapePath,\n        applyChecksum,\n    }: SignatureV4Options) {\n        this.service = service\n        this.region = region\n        this.credentials = credentials\n        this.uriEscapePath = typeof uriEscapePath === 'boolean' ? uriEscapePath : true\n        this.applyChecksum = typeof applyChecksum === 'boolean' ? applyChecksum : true\n    }\n\n    /**\n     * Includes AWS v4 signing information to the provided HTTP request.\n     *\n     * This method adds an Authorization header to the request, containing\n     * the signature and other signing information. It also returns a preformatted\n     * URL that can be used to make the k6 http request.\n     *\n     * This method mutates the request object.\n     *\n     * @param request {HTTPRequest} The request to sign.\n     * @param param1 {SignOptions} Options for signing the request.\n     * @returns {SignedHTTPRequest} The signed request.\n     */\n    sign(\n        request: HTTPRequest,\n        {\n            signingDate = new Date(),\n            signingService,\n            signingRegion,\n            unsignableHeaders = new Set<string>(),\n            signableHeaders = new Set<string>(),\n        }: RequestSigningOptions\n    ): SignedHTTPRequest {\n        const { longDate, shortDate }: DateInfo = formatDate(signingDate)\n        const service = signingService || this.service\n        const region = signingRegion || this.region\n        const scope = `${shortDate}/${region}/${service}/${constants.KEY_TYPE_IDENTIFIER}`\n\n        // Required by the specification:\n        //   \"For HTTP/1.1 requests, you must include the host header at a minimum.\n        //   Standard headers like content-type are optional.\n        //   For HTTP/2 requests, you must include the :authority header instead of\n        //   the host header. Different services might require other headers.\"\n        request.headers[constants.HOST_HEADER] = request.hostname\n\n        // Filter out headers that will be generated and managed by the signing process.\n        // If the user provide any of those as part of the HTTPRequest's headers, they\n        // will be ignored.\n        for (const headerName of Object.keys(request.headers)) {\n            if (constants.GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {\n                delete request.headers[headerName]\n            }\n        }\n\n        request.headers[constants.AMZ_DATE_HEADER] = longDate\n        if (this.credentials.sessionToken) {\n            request.headers[constants.AMZ_TOKEN_HEADER] = this.credentials.sessionToken\n        }\n\n        // If the request body is a typed array, we need to convert it to a buffer\n        // so that we can calculate the checksum.\n        if (ArrayBuffer.isView(request.body)) {\n            request.body = request.body.buffer\n        }\n\n        // Ensure we avoid passing undefined to the crypto hash function.\n        if (!request.body) {\n            request.body = ''\n        }\n\n        let payloadHash = this.computePayloadHash(request)\n        if (!hasHeader(constants.AMZ_CONTENT_SHA256_HEADER, request.headers) && this.applyChecksum) {\n            request.headers[constants.AMZ_CONTENT_SHA256_HEADER] = payloadHash\n        }\n\n        const canonicalHeaders = this.computeCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n        const signature = this.calculateSignature(\n            longDate,\n            scope,\n            this.deriveSigningKey(this.credentials, service, region, shortDate),\n            this.createCanonicalRequest(request, canonicalHeaders, payloadHash),\n        );\n\n        /**\n         * Step 4 of the signing process: add the signature to the HTTP request's headers.\n         *\n         * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n         */\n        request.headers[constants.AUTHORIZATION_HEADER] =\n            `${constants.SIGNING_ALGORITHM_IDENTIFIER} ` +\n            `Credential=${this.credentials.accessKeyId}/${scope}, ` +\n            `SignedHeaders=${Object.keys(canonicalHeaders).sort().join(';')}, ` +\n            `Signature=${signature}`\n\n        // If a request path was provided, add it to the URL\n        let url = `${request.protocol}://${request.hostname}`\n        if (request.path) {\n            url += request.path\n        }\n\n        // If a request query string was provided, add it to the URL\n        if (request.query) {\n            // We exclude the signature from the query string\n            url += `?${this.serializeQueryParameters(request.query)}`\n        }\n\n        return {\n            url: url,\n            ...request,\n        }\n    }\n\n    /**\n     * Produces a presigned URL with AWS v4 signature information for the provided HTTP request.\n     *\n     * A presigned URL is a URL that contains the authorization information\n     * (signature and other signing information) in the query string. This method\n     * returns a preformatted URL that can be used to make the k6 http request.\n     *\n     * @param originalRequest - The original request to presign.\n     * @param options - Options controlling the signing of the request.\n     * @returns A signed request, including the presigned URL.\n     */\n    presign(originalRequest: HTTPRequest, options: PresignOptions = {}): SignedHTTPRequest {\n        const {\n            signingDate = new Date(),\n            expiresIn = 3600,\n            unsignableHeaders,\n            unhoistableHeaders,\n            signableHeaders,\n            signingRegion,\n            signingService,\n        } = options\n        const { longDate, shortDate }: DateInfo = formatDate(signingDate)\n        const region = signingRegion || this.region\n        const service = signingService || this.service\n\n        if (expiresIn > constants.MAX_PRESIGNED_TTL) {\n            throw new InvalidSignatureError(\n                \"Signature version 4 presigned URLs can't be valid for more than 7 days\"\n            )\n        }\n\n        const scope = `${shortDate}/${region}/${service}/${constants.KEY_TYPE_IDENTIFIER}`\n        const request = this.moveHeadersToQuery(originalRequest, { unhoistableHeaders })\n\n        // Required by the specification:\n        //   \"For HTTP/1.1 requests, you must include the host header at a minimum.\n        //   Standard headers like content-type are optional.\n        //   For HTTP/2 requests, you must include the :authority header instead of\n        //   the host header. Different services might require other headers.\"\n        request.headers[constants.HOST_HEADER] = originalRequest.hostname\n\n        // If the user provided a session token, include it in the signed url query string.\n        if (this.credentials.sessionToken) {\n            request.query[constants.AMZ_TOKEN_QUERY_PARAM] = this.credentials.sessionToken\n        }\n\n        // Add base signing query parameters to the request, as described in the documentation\n        // @see https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n        request.query[constants.AMZ_ALGORITHM_QUERY_PARAM] = constants.SIGNING_ALGORITHM_IDENTIFIER\n        request.query[\n            constants.AMZ_CREDENTIAL_QUERY_PARAM\n        ] = `${this.credentials.accessKeyId}/${scope}`\n        request.query[constants.AMZ_DATE_QUERY_PARAM] = longDate\n        request.query[constants.AMZ_EXPIRES_QUERY_PARAM] = expiresIn.toString(10)\n\n        const canonicalHeaders = this.computeCanonicalHeaders(\n            request,\n            unsignableHeaders,\n            signableHeaders\n        )\n        request.query[constants.AMZ_SIGNED_HEADERS_QUERY_PARAM] = Object.keys(canonicalHeaders)\n            .sort()\n            .join(';')\n\n        const signingKey = this.deriveSigningKey(this.credentials, service, region, shortDate)\n\n        // Computing the payload from the original request. This is required\n        // in the event the user attempts to produce a presigned URL for s3,\n        // which requires the payload hash to be 'UNSIGNED-PAYLOAD'.\n        //\n        // To that effect, users need to set the 'x-amz-content-sha256' header,\n        // and mark it as unhoistable and unsignable. When setup this way,\n        // the computePayloadHash method will then return the string 'UNSIGNED-PAYLOAD'.\n        const payloadHash = this.computePayloadHash(originalRequest)\n        const canonicalRequest = this.createCanonicalRequest(request, canonicalHeaders, payloadHash)\n\n        request.query[constants.AMZ_SIGNATURE_QUERY_PARAM] = this.calculateSignature(\n            longDate,\n            scope,\n            signingKey,\n            canonicalRequest\n        )\n\n        // If a request path was provided, add it to the URL\n        let url = `${request.protocol}://${request.hostname}`\n        if (request.path) {\n            url += request.path\n        }\n\n        // If a request query string was provided, add it to the URL\n        if (request.query) {\n            url += `?${this.serializeQueryParameters(request.query)}`\n        }\n\n        return { url: url, ...request }\n    }\n\n    /**\n     * Create a string including information from your request\n     * in a AWS signature v4 standardized (canonical) format.\n     *\n     * Step 1 of the signing process: create the canonical request string.\n     * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\n     *\n     * @param request {HTTPRequest} The request to sign.\n     * @param canonicalHeaders {HTTPHeaderBag} The request's canonical headers.\n     * @param payloadHash {string} The hexadecimally encoded request's payload hash .\n     * @returns {string} The canonical request string.\n     */\n    private createCanonicalRequest(\n        request: HTTPRequest,\n        canonicalHeaders: HTTPHeaderBag,\n        payloadHash: string\n    ): string {\n        const sortedHeaders = Object.keys(canonicalHeaders).sort()\n        const sortedCanonicalHeaders = sortedHeaders\n            .map((name) => `${name}:${canonicalHeaders[name]}`)\n            .join('\\n')\n        const signedHeaders = sortedHeaders.join(';')\n\n        return (\n            `${request.method}\\n` +\n            `${this.computeCanonicalURI(request)}\\n` +\n            `${this.computeCanonicalQuerystring(request)}\\n` +\n            `${sortedCanonicalHeaders}\\n\\n` +\n            `${signedHeaders}\\n` +\n            `${payloadHash}`\n        )\n    }\n\n    /**\n     * Create the \"string to sign\" part of the signature Version 4 protocol.\n     *\n     * The \"string to sign\" includes meta information about your request and\n     * about the canonical request that you created with `createCanonicalRequest`.\n     * It is used hand in hand with the signing key to create the request signature.\n     * Step 2 of the signing process: create the string to sign.\n     * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n     *\n     * @param longDate {string} The request's date in iso 8601 format.\n     * @param credentialScope {string} The request's credential scope.\n     * @param canonicalRequest {string} The request's canonical request.\n     * @returns {string} The \"string to sign\".\n     */\n    private createStringToSign(\n        longDate: string,\n        credentialScope: string,\n        canonicalRequest: string\n    ): string {\n        const hashedCanonicalRequest = crypto.sha256(canonicalRequest, 'hex')\n\n        return (\n            `${constants.SIGNING_ALGORITHM_IDENTIFIER}\\n` +\n            `${longDate}\\n` +\n            `${credentialScope}\\n` +\n            `${hashedCanonicalRequest}`\n        )\n    }\n\n    /**\n     * Calculte the signature for AWS signature version 4.\n     *\n     * Step 3 of the signing process: create the signature.\n     * @see https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n     *\n     * @param longDate {string} The request's date in iso 8601 format.\n     * @param credentialScope {string} The request's credential scope.\n     * @param signingKey {string} the signing key as computed by the deriveSigningKey method.\n     * @param canonicalRequest {string} The request's canonical request.\n     * @returns {string} The signature.\n     */\n    private calculateSignature(\n        longDate: string,\n        credentialScope: string,\n        signingKey: Uint8Array,\n        canonicalRequest: string\n    ): string {\n        const stringToSign = this.createStringToSign(longDate, credentialScope, canonicalRequest)\n        return crypto.hmac('sha256', signingKey, stringToSign, 'hex')\n    }\n\n    /**\n     * Derives the signing key for authenticating requests signed with\n     * the Signature version 4 authentication protocol.\n     *\n     * deriveSigningKey produces a signing key by creating a series of\n     * hash-based message authentication codes (HMACs) represented in\n     * a binary format.\n     *\n     * The derived signing key is specific to the date it's made at, as well as\n     * the service and region it targets.\n     *\n     * @param credentials {AWSCredentials} The credentials to use for signing.\n     * @param service {string} The service the request is targeted at.\n     * @param region {string} The region the request is targeted at.\n     * @param shortDate {string} The request's date in YYYYMMDD format.\n     * @returns {Uint8Array} The derived signing key.\n     */\n    private deriveSigningKey(\n        credentials: Credentials,\n        service: string,\n        region: string,\n        shortDate: string\n    ): Uint8Array {\n        const kSecret: string = credentials.secretAccessKey\n        const kDate: any = crypto.hmac('sha256', 'AWS4' + kSecret, shortDate, 'binary')\n        const kRegion: any = crypto.hmac('sha256', kDate, region, 'binary')\n        const kService: any = crypto.hmac('sha256', kRegion, service, 'binary')\n        const kSigning: any = crypto.hmac('sha256', kService, 'aws4_request', 'binary')\n\n        return kSigning\n    }\n\n    /**\n     * Create a string that includes information from your request\n     * in a AWS signature v4 standardized (canonical) format.\n     *\n     * @param param0 {HTTPRequest} The request to sign.\n     * @returns {string} The canonical URI.\n     */\n    private computeCanonicalURI({ path }: HTTPRequest): string {\n        if (this.uriEscapePath) {\n            // Non-S3 services, we normalize the path and then double URI encode it.\n            // Ref: \"Remove Dot Segments\" https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4\n            const normalizedURISegments = []\n\n            for (const URISegment of path.split('/')) {\n                if (URISegment?.length === 0) {\n                    continue\n                }\n\n                if (URISegment === '.') {\n                    continue\n                }\n\n                if (URISegment === '..') {\n                    normalizedURISegments.pop()\n                } else {\n                    normalizedURISegments.push(URISegment)\n                }\n            }\n\n            // Normalize the URI\n            const leading = path?.startsWith('/') ? '/' : ''\n            const URI = normalizedURISegments.join('/')\n            const trailing = normalizedURISegments.length > 0 && path?.endsWith('/') ? '/' : ''\n            const normalizedURI = `${leading}${URI}${trailing}`\n\n            const doubleEncoded = encodeURIComponent(normalizedURI)\n\n            return doubleEncoded.replace(/%2F/g, '/')\n        }\n\n        // For S3, we shouldn't normalize the path. For example, object name\n        // my-object//example//photo.user should not be normalized to\n        // my-object/example/photo.user\n        return path\n    }\n\n    /**\n     * Serializes the request's query parameters into their canonical\n     * string version. If the request does not include a query parameters,\n     * returns an empty string.\n     *\n     * @param param0 {HTTPRequest} The request containing the query parameters.\n     * @returns {string} The canonical query string.\n     */\n    private computeCanonicalQuerystring({ query = {} }: HTTPRequest): string {\n        const keys: Array<string> = []\n        const serialized: Record<string, string> = {}\n\n        for (const key of Object.keys(query).sort()) {\n            if (key.toLowerCase() === constants.AMZ_SIGNATURE_HEADER) {\n                continue\n            }\n\n            keys.push(key)\n            const value = query[key]\n\n            if (typeof value === 'string') {\n                serialized[key] = `${escapeURI(key)}=${escapeURI(value)}`\n            } else if (Array.isArray(value)) {\n                serialized[key] = value\n                    .slice(0)\n                    .sort()\n                    .reduce(\n                        (encoded: Array<string>, value: string) =>\n                            encoded.concat([`${escapeURI(key)}=${escapeURI(value)}`]),\n                        []\n                    )\n                    .join('&')\n            }\n        }\n\n        return keys\n            .map((key) => serialized[key])\n            .filter((serialized) => serialized)\n            .join('&')\n    }\n\n    /**\n     * Create the canonical form of the request's headers.\n     * Canonical headers consist of all the HTTP headers you\n     * are including with the signed request.\n     *\n     * @param param0 {HTTPRequest} The request to compute the canonical headers of.\n     * @param unsignableHeaders {Set<string>} The headers that should not be signed.\n     * @param signableHeaders {Set<string>} The headers that should be signed.\n     * @returns {string} The canonical headers.\n     */\n    private computeCanonicalHeaders(\n        { headers }: HTTPRequest,\n        unsignableHeaders?: Set<string>,\n        signableHeaders?: Set<string>\n    ): HTTPHeaderBag {\n        const canonicalHeaders: HTTPHeaderBag = {}\n\n        for (const headerName of Object.keys(headers).sort()) {\n            if (headers[headerName] == undefined) {\n                continue\n            }\n\n            const canonicalHeaderName = headerName.toLowerCase()\n            if (\n                canonicalHeaderName in constants.ALWAYS_UNSIGNABLE_HEADERS ||\n                unsignableHeaders?.has(canonicalHeaderName)\n            ) {\n                if (\n                    !signableHeaders ||\n                    (signableHeaders && !signableHeaders.has(canonicalHeaderName))\n                ) {\n                    continue\n                }\n            }\n\n            canonicalHeaders[canonicalHeaderName] = headers[headerName].trim().replace(/\\s+/g, ' ')\n        }\n\n        return canonicalHeaders\n    }\n\n    /**\n     * Computes the SHA256 cryptographic hash of the request's body.\n     *\n     * If the headers contain the 'X-Amz-Content-Sha256' header, then\n     * the value of that header is returned instead. This proves useful\n     * when, for example, presiging a URL for S3, as the payload hash\n     * must always be equal to 'UNSIGNED-PAYLOAD'.\n     *\n     * @param param0 {HTTPRequest} The request to compute the payload hash of.\n     * @returns {string} The hex encoded SHA256 payload hash, or the value of the 'X-Amz-Content-Sha256' header.\n     */\n    private computePayloadHash({ headers, body }: HTTPRequest): string {\n        // for (const headerName of Object.keys(headers)) {\n        //     // If the header is present, return its value.\n        //     // So that we let the 'UNSIGNED-PAYLOAD' value pass through.\n        //     if (headerName.toLowerCase() === constants.AMZ_CONTENT_SHA256_HEADER) {\n        //         return headers[headerName]\n        //     }\n        // }\n\n        if (headers[constants.AMZ_CONTENT_SHA256_HEADER]) {\n            return headers[constants.AMZ_CONTENT_SHA256_HEADER]\n        }\n\n        if (body == undefined) {\n            return constants.EMPTY_SHA256\n        }\n\n        if (typeof body === 'string' || isArrayBuffer(body)) {\n            return crypto.sha256(body, 'hex').toLowerCase()\n        }\n\n        if (ArrayBuffer.isView(body)) {\n            // If the request body is a typed array, we need to convert it to a buffer\n            // so that we can calculate the checksum.\n            return crypto.sha256((body as DataView).buffer, 'hex').toLowerCase()\n        }\n\n        return constants.UNSIGNED_PAYLOAD\n    }\n\n    /**\n     * Moves a request's headers to its query parameters.\n     *\n     * The operation will ignore any amazon standard headers, prefixed\n     * with 'X-Amz-'. It will also ignore any headers specified as unhoistable\n     * by the options.\n     *\n     * The operation will delete the headers from the request.\n     *\n     * @param request {HTTPRequest} The request to move the headers from.\n     * @param options\n     * @returns {HTTPRequest} The request with the headers moved to the query parameters.\n     */\n    private moveHeadersToQuery(\n        request: HTTPRequest,\n        options: { unhoistableHeaders?: Set<string> } = {}\n    ): HTTPRequest & { query: QueryParameterBag } {\n        const requestCopy = JSON.parse(JSON.stringify(request))\n        const { headers, query = {} as QueryParameterBag } = requestCopy\n\n        for (const name of Object.keys(headers)) {\n            const lowerCaseName = name.toLowerCase()\n            if (\n                lowerCaseName.slice(0, 6) === 'x-amz-' &&\n                !options.unhoistableHeaders?.has(lowerCaseName)\n            ) {\n                query[name] = headers[name]\n                delete headers[name]\n            }\n        }\n\n        return {\n            ...requestCopy,\n            headers,\n            query,\n        }\n    }\n\n    /**\n     * Serializes a HTTPRequest's query parameter bag into a string.\n     *\n     * @param query {QueryParameterBag} The query parameters to serialize.\n     * @param ignoreKeys {Set<string>} The keys to ignore.\n     * @returns {string} The serialized, and ready to use in a URL, query parameters.\n     */\n    private serializeQueryParameters(query: QueryParameterBag, ignoreKeys?: string[]): string {\n        const keys: Array<string> = []\n        const serialized: Record<string, string> = {}\n\n        for (const key of Object.keys(query).sort()) {\n            if (ignoreKeys?.includes(key.toLowerCase())) {\n                continue\n            }\n\n            keys.push(key)\n            const value = query[key]\n\n            if (typeof value === 'string') {\n                serialized[key] = `${escapeURI(key)}=${escapeURI(value)}`\n            } else if (Array.isArray(value)) {\n                serialized[key] = value\n                    .slice(0)\n                    .sort()\n                    .reduce(\n                        (encoded: Array<string>, value: string) =>\n                            encoded.concat([`${escapeURI(key)}=${escapeURI(value)}`]),\n                        []\n                    )\n                    .join('&')\n            }\n        }\n\n        return keys\n            .map((key) => serialized[key])\n            .filter((serialized) => serialized)\n            .join('&')\n    }\n}\n\n/**\n * Error indicating an Invalid signature has been sent to AWS services\n *\n * Inspired from AWS official error types, as\n * described in:\n *   * https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/\n *   * https://github.com/aws/aws-sdk-js/blob/master/lib/error.d.ts\n */\nexport class InvalidSignatureError extends AWSError {\n    /**\n     * Constructs an InvalidSignatureError\n     *\n     * @param  {string} message - human readable error message\n     */\n    constructor(message: string, code?: string) {\n        super(message, code)\n        this.name = 'InvalidSignatureError'\n    }\n}\n\nexport interface SignatureV4Options {\n    /**\n     * The name of the service to sign for.\n     */\n    service: string\n\n    /**\n     * The name of the region to sign for.\n     */\n    region: string\n\n    /**\n     * The credentials with which the request should be signed.\n     */\n    credentials: Credentials\n\n    /**\n     * Whether to uri-escape the request URI path as part of computing the\n     * canonical request string. This is required for every AWS service, except\n     * Amazon S3, as of late 2017.\n     *\n     * @default [true]\n     */\n    uriEscapePath?: boolean\n\n    /**\n     * Whether to calculate a checksum of the request body and include it as\n     * either a request header (when signing) or as a query string parameter\n     * (when presigning). This is required for AWS Glacier and Amazon S3 and optional for\n     * every other AWS service as of late 2017.\n     *\n     * @default [true]\n     */\n    applyChecksum?: boolean\n}\n\nexport interface SignOptions {\n    /**\n     * The date and time to be used as signature metadata. This value should be\n     * a Date object, a unix (epoch) timestamp, or a string that can be\n     * understood by the JavaScript `Date` constructor.If not supplied, the\n     * value returned by `new Date()` will be used.\n     */\n    signingDate?: Date\n\n    /**\n     * The service signing name. It will override the service name of the signer\n     * in current invocation\n     */\n    signingService?: string\n\n    /**\n     * The region name to sign the request. It will override the signing region of the\n     * signer in current invocation\n     */\n    signingRegion?: string\n}\n\nexport interface RequestSigningOptions extends SignOptions {\n    /**\n     * A set of strings whose members represents headers that cannot be signed.\n     * All headers in the provided request will have their names converted to\n     * lower case and then checked for existence in the unsignableHeaders set.\n     */\n    unsignableHeaders?: Set<string>\n\n    /**\n     * A set of strings whose members represents headers that should be signed.\n     * Any values passed here will override those provided via unsignableHeaders,\n     * allowing them to be signed.\n     *\n     * All headers in the provided request will have their names converted to\n     * lower case before signing.\n     */\n    signableHeaders?: Set<string>\n}\n\nexport interface PresignOptions extends RequestSigningOptions {\n    /**\n     * The number of seconds before the presigned URL expires\n     */\n    expiresIn?: number\n\n    /**\n     * A set of strings whose representing headers that should not be hoisted\n     * to presigned request's query string. If not supplied, the presigner\n     * moves all the AWS-specific headers (starting with `x-amz-`) to the request\n     * query string. If supplied, these headers remain in the presigned request's\n     * header.\n     * All headers in the provided request will have their names converted to\n     * lower case and then checked for existence in the unhoistableHeaders set.\n     */\n    unhoistableHeaders?: Set<string>\n}\n\nexport interface Credentials {\n    /**\n     * AWS access key ID\n     */\n    readonly accessKeyId: string\n\n    /**\n     * AWS secret access key\n     */\n    readonly secretAccessKey: string\n\n    /**\n     * A security or session token to use with these credentials. Usually\n     * present for temporary credentials.\n     */\n    readonly sessionToken?: string\n}\n\nexport interface DateInfo {\n    /**\n     * ISO8601 formatted date string\n     */\n    longDate: string\n\n    /**\n     * String in the format YYYYMMDD\n     */\n    shortDate: string\n}\n\n/**\n * Escapes a URI following the AWS signature v4 escaping rules.\n *\n * @param URI {string} The URI to escape.\n * @returns {string} The escaped URI.\n */\nfunction escapeURI(URI: string): string {\n    const hexEncode = (c: string): string => {\n        return `%${c.charCodeAt(0).toString(16).toUpperCase()}`\n    }\n\n    return encodeURIComponent(URI).replace(/[!'()*]/g, hexEncode)\n}\n\n/**\n * formatDate formats a Date object into a ISO8601 formatted date string\n * and a string in the format YYYYMMDD.\n *\n * @param date {Date} The date to format.\n * @returns {DateInfo} The formatted date.\n */\nfunction formatDate(date: Date): DateInfo {\n    const longDate = iso8601(date).replace(/[\\-:]/g, '')\n    return {\n        longDate,\n        shortDate: longDate.slice(0, 8),\n    }\n}\n\n/**\n * Formats a time into an ISO 8601 string.\n *\n * @see https://en.wikipedia.org/wiki/ISO_8601\n *\n * @param time {number | string | Date} The time to format.\n * @returns {string} The ISO 8601 formatted time.\n */\nfunction iso8601(time: number | string | Date): string {\n    return toDate(time)\n        .toISOString()\n        .replace(/\\.\\d{3}Z$/, 'Z')\n}\n\n/**\n * Converts a time value into a Date object.\n *\n * @param time {number | string | Date} The time to convert.\n * @returns {Date} The resulting Date object.\n */\nfunction toDate(time: number | string | Date): Date {\n    if (typeof time === 'number') {\n        return new Date(time * 1000)\n    }\n\n    if (typeof time === 'string') {\n        if (Number(time)) {\n            return new Date(Number(time) * 1000)\n        }\n\n        return new Date(time)\n    }\n\n    return time\n}\n","/**\n * Type representing HTTP schemes\n */\nexport type HTTPScheme = 'http' | 'https'\n\n/**\n * Type representing HTTP Methods\n *\n */\nexport type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE'\n\n/**\n * Type alias representing HTTP Headers\n */\nexport type HTTPHeaders = { [key: string]: string }\n\n/**\n * HTTPHeaderBag is a type alias representing HTTP Headers\n */\nexport type HTTPHeaderBag = Record<string, string>\n\nexport function hasHeader(soughtHeader: string, headers: HTTPHeaderBag): boolean {\n    soughtHeader = soughtHeader.toLowerCase()\n\n    for (const headerName of Object.keys(headers)) {\n        if (soughtHeader === headerName.toLowerCase()) {\n            return true\n        }\n    }\n\n    return false\n}\n\n/**\n * QueryParameterBag is a type alias representing HTTP Query Parameters\n */\nexport type QueryParameterBag = Record<string, string | Array<string>>\n\n/**\n * HTTPRequest represents an HTTP request\n */\nexport interface HTTPRequest {\n    /**\n     * The HTTP method to use\n     */\n    method: HTTPMethod\n\n    /**\n     * The protocol to use (http or https)\n     */\n    protocol: HTTPScheme\n\n    /**\n     * The hostname (domain name or IP address) the request targets\n     */\n    hostname: string\n\n    /**\n     * The port to the request targets\n     */\n    port?: number\n\n    /**\n     * The path to the resource\n     */\n    path: string\n\n    /**\n     * The query parameters to include in the request\n     */\n    query?: QueryParameterBag\n\n    /**\n     * The headers to include in the request\n     */\n    headers: HTTPHeaderBag\n\n    /**\n     * The body of the request\n     */\n    body?: string | ArrayBuffer | null\n}\n\n/**\n * SignedHTTPRequest represents an HTTP request that has been signed\n * with an AWS signature. It is a superset of HTTPRequest adding\n * the following fields:\n * - url: the fully qualified URL of the request that can be used in a k6 http.request.\n */\nexport interface SignedHTTPRequest extends HTTPRequest {\n    url: string\n}\n","/**\n *\n * @param value\n * @returns\n */\nexport function isArrayBuffer(value: any): value is ArrayBuffer {\n    return (\n        typeof ArrayBuffer === 'function' &&\n        (value instanceof ArrayBuffer ||\n            Object.prototype.toString.call(value) === '[object ArrayBuffer]')\n    )\n}\n\nexport function toFormUrlEncoded(form: any): string {\n    return Object.keys(form).reduce((params, key) => {\n        let value = form[key]\n        if (value !== undefined && value !== null) {\n            params.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`)\n        }\n        return params;\n    }, [] as string[]).join('&')\n}","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"k6/http\");","/**\n * It creates a new KinesisClient object and returns it.\n * @param {T} obj - T - The object that we're checking for the key.\n * @param k - The number of virtual users to simulate.\n */\nimport { JSONArray, JSONObject } from 'k6'\nimport http, { RefinedResponse, ResponseType } from 'k6/http'\n\nimport { AWSClient } from './client'\n\nimport { AWSConfig } from './config'\nimport { AMZ_TARGET_HEADER } from './constants'\nimport { AWSError } from './error'\nimport { HTTPHeaders } from './http'\nimport { InvalidSignatureError, SignatureV4 } from './signature'\n\n\n/**\nThis API is based on\nhttps://docs.aws.amazon.com/kinesis/latest/APIReference/API_Operations.html\n*/\n\n\n/* This class is a wrapper around the AWS Kinesis client. It provides a method for each Kinesis\noperation, and each method returns a promise. */\nexport class KinesisClient extends AWSClient {\n\n    signature: SignatureV4\n\n    commonHeaders: HTTPHeaders\n\n    serviceVersion: string\n\n    /**\n     * A constructor function that creates a new instance of the Kinesis class.\n     * @param {AWSConfig} awsConfig - AWSConfig - This is the configuration object that is passed to\n     * the constructor.\n     * @returns A Proxy object.\n     */\n    constructor(awsConfig: AWSConfig) {\n        super(awsConfig, 'kinesis')\n\n        this.serviceVersion = 'Kinesis_20131202'\n\n        this.signature = new SignatureV4({\n            service: this.serviceName,\n            region: this.awsConfig.region,\n            credentials: {\n                accessKeyId: this.awsConfig.accessKeyId,\n                secretAccessKey: this.awsConfig.secretAccessKey,\n                sessionToken: this.awsConfig.sessionToken,\n            },\n            uriEscapePath: false,\n            applyChecksum: true,\n        })\n\n\n        this.commonHeaders = {\n            'Content-Type': 'application/x-amz-json-1.1',\n        }\n\n        return new Proxy(this, {\n            get: function (client, target) {\n                return hasKey(client, target) ? client[target] : function () {\n                    return client.RequestOperation.apply(this, [target.toString(), arguments[0]]);\n                };\n            }\n        });\n    }\n\n\n    /**\n     * It makes a request to the AWS API.\n     * @param {string} target - The name of the API method you want to call.\n     * @param {JSONObject} options - JSONObject = {}\n     * @returns A RefinedResponse<ResponseType | undefined>\n     */\n    RequestOperation(target: string,\n        options: JSONObject | CreateStreamRequest | PutRecordsRequest | DeleteStreamRequest | Partial<ListStreamRequest> = {}): RefinedResponse<ResponseType | undefined> | undefined {\n\n        // handling additional operations as lib standard\n        target = target[0].toUpperCase() + target.slice(1)\n\n        const signedRequest = this.signature.sign(\n            {\n                method: 'POST',\n                protocol: this.awsConfig.scheme,\n                hostname: this.host,\n                path: '/',\n                headers: {\n                    ...this.commonHeaders,\n                    [AMZ_TARGET_HEADER]: `${this.serviceVersion}.${target}`,\n                },\n                body: JSON.stringify(options),\n            },\n            {}\n        )\n\n        let res = undefined;\n        try {\n            res = http.request('POST', signedRequest.url, signedRequest.body, {\n                headers: signedRequest.headers,\n            })\n\n            this._handle_error(target, res)\n        }\n        catch (err) {\n            console.log(\"Error with current request from k6-jslib-aws-extension\")\n            console.log(err)\n        }\n\n        return res\n    }\n\n    /**\n     * If the response is an error, throw an error\n     * @param {string} operation - The name of the operation that was called.\n     * @param response - RefinedResponse<ResponseType | undefined>\n     * @returns The response is being returned.\n     */\n    _handle_error(\n        operation: string,\n        response: RefinedResponse<ResponseType | undefined>\n    ) {\n        const errorCode = response.error_code\n        if (errorCode === 0) {\n            return\n        }\n\n        console.log(\"Error with current response from k6-jslib-aws-extension\")\n        console.log(response)\n\n        const error = response.json() as JSONObject\n        if (errorCode >= 1400 && errorCode <= 1499) {\n            // In the event of certain errors, the message is not set.\n            // Also, note the inconsistency in casing...\n            const errorMessage: string =\n                (error.Message as string) || (error.message as string) || (error.__type as string)\n\n            // Handle specifically the case of an invalid signature\n            if (error.__type === 'InvalidSignatureException') {\n                throw new InvalidSignatureError(errorMessage, error.__type)\n            }\n\n            // Otherwise throw a standard service error\n            throw new KinesisServiceError(errorMessage, error.__type as string, operation)\n        }\n\n        if (errorCode === 1500) {\n            throw new KinesisServiceError(\n                'An error occured on the server side',\n                'InternalServiceError',\n                operation\n            )\n        }\n    }\n\n\n\n    /**\n     * It creates a stream.\n     * @param {CreateStreamRequest} request - CreateStreamRequest - The request object that will be\n     * sent to the server.\n     */\n    createStream(request: CreateStreamRequest): void {\n        this.RequestOperation(`CreateStream`, request)\n    }\n\n    /**\n     * It deletes a stream.\n     * @param request - Partial<DeleteStreamRequest>\n     */\n    deleteStream(request: Partial<DeleteStreamRequest>): void {\n        this.RequestOperation(`DeleteStream`, request)\n    }\n\n    /**\n     * It returns a list of streams.\n     * @param request - Partial<ListStreamRequest> = {}\n     * @returns A partial of the ListStreamsResponse class.\n     */\n    listStreams(request: Partial<ListStreamRequest> = {}): Partial<ListStreamsResponse> {\n        const res = this.RequestOperation(`ListStreams`, request)\n        return ListStreamsResponse.fromJson(res.json())\n    }\n\n    /**\n     * It takes a request object and returns a response object.\n     * @param {PutRecordsRequest} request - PutRecordsRequest\n     * @returns A partial of the PutRecordsResponse class.\n     */\n    putRecords(request: PutRecordsRequest): Partial<PutRecordsResponse> {\n        const res = this.RequestOperation(`PutRecords`, request)\n        return PutRecordsResponse.fromJson(res.json())\n    }\n\n    /**\n     * It gets the records from the database.\n     * @param {GetRecordsRequest} request - GetRecordsRequest\n     * @returns A partial of the GetRecordsResponse class.\n     */\n    getRecords(request: GetRecordsRequest): Partial<GetRecordsResponse> {\n        const res = this.RequestOperation(`GetRecords`, request)\n        return GetRecordsResponse.fromJson(res.json())\n    }\n\n    /**\n     * It lists the shards in a stream.\n     * @param {ListShardsRequest} request - The request object that is passed to the API.\n     * @returns ListShardsResponse\n     */\n    listShards(request: ListShardsRequest): ListShardsResponse {\n        const res = this.RequestOperation(`ListShards`, request)\n        return ListShardsResponse.fromJson(res.json())\n    }\n\n\n    /**\n     * \n     * @param {GetShardIteratorRequest} request - GetShardIteratorRequest\n     * @returns GetShardIteratorResponse\n     */\n    getShardIterator(request: GetShardIteratorRequest): GetShardIteratorResponse {\n        const res = this.RequestOperation(`GetShardIterator`, request)\n        return GetShardIteratorResponse.fromJson(res.json())\n    }\n}\n\n/* Defining the interface for the CreateStreamRequest. */\nexport interface CreateStreamRequest {\n    ShardCount?: number,\n    StreamModeDetails?: {\n        StreamMode: 'PROVISIONED' | 'ON_DEMAND'\n    },\n    StreamName: string\n}\n\n\n/* Defining the interface for the DeleteStreamRequest. */\nexport interface DeleteStreamRequest {\n    EnforceConsumerDeletion: boolean,\n    StreamARN: string,\n    StreamName: string\n}\n\n\nexport interface ListStreamRequest {\n    ExclusiveStartStreamName: string,\n    Limit: number,\n    NextToken: string\n}\n\nexport class StreamSummary {\n    StreamARN: string;\n    StreamCreationTimestamp: number;\n    StreamModeDetails: {\n        StreamMode: string;\n    };\n    StreamName: string;\n    StreamStatus: string;\n\n    constructor(\n        StreamARN: string,\n        StreamCreationTimestamp: number,\n        StreamMode: string,\n        StreamName: string,\n        StreamStatus: string,\n    ) {\n        this.StreamARN = StreamARN;\n        this.StreamCreationTimestamp = StreamCreationTimestamp;\n        this.StreamModeDetails = { StreamMode };\n        this.StreamName = StreamName;\n        this.StreamStatus = StreamStatus;\n    }\n\n    static fromJson(summary: any): StreamSummary {\n        return new StreamSummary(\n            summary.StreamARN as string,\n            summary.StreamCreationTimestamp as number,\n            (summary.StreamModeDetails as JSONObject).streammode as string,\n            summary.StreamName as string,\n            summary.StreamStatus as string,\n        )\n    }\n}\n\nexport class ListStreamsResponse {\n    HasMoreStreams: boolean;\n    NextToken?: string;\n    StreamNames: string[];\n    StreamSummaries: StreamSummary[];\n\n    constructor(\n        HasMoreStreams: boolean,\n        NextToken: string,\n        StreamNames: string[],\n        StreamSummaries: StreamSummary[]\n    ) {\n        this.HasMoreStreams = HasMoreStreams;\n        this.NextToken = NextToken;\n        this.StreamNames = StreamNames;\n        this.StreamSummaries = StreamSummaries\n    }\n\n    static fromJson(result: any): ListStreamsResponse {\n        let response = new ListStreamsResponse(\n            result.HasMoreStreams as boolean,\n            result.NextToken ? result.NextToken as string : \"\",\n            result.StreamNames ? (result.StreamNames as JSONArray).map(s => String(s)) : [],\n            result.StreamSummaries ? (result.StreamSummaries as JSONArray).map(s => StreamSummary.fromJson(s)) : []\n        )\n\n        return response\n    }\n}\n\n// Request class for PutRecords API\nexport interface PutRecordsRequest {\n    Records: PutRecordsRequestRecord[];\n    StreamName: string;\n}\n\nexport interface PutRecordsRequestRecord {\n    Data: string | ArrayBuffer;\n    PartitionKey: string;\n}\n\n\n// Response class for PutRecords API\nexport class PutRecordsResponse {\n    FailedRecordCount: number;\n    Records: PutRecordsResponseRecord[];\n\n    constructor(failedRecordCount: number, records: PutRecordsResponseRecord[]) {\n        this.FailedRecordCount = failedRecordCount;\n        this.Records = records;\n    }\n\n    static fromJson(json: any): PutRecordsResponse {\n        const failedRecordCount = json.FailedRecordCount;\n        const records = json.Records.map(record => PutRecordsResponseRecord.fromJson(record));\n        return new PutRecordsResponse(failedRecordCount, records);\n    }\n}\n\nexport class PutRecordsResponseRecord {\n    SequenceNumber: string;\n    ShardId: string;\n\n    constructor(sequenceNumber: string, shardId: string) {\n        this.SequenceNumber = sequenceNumber;\n        this.ShardId = shardId;\n    }\n\n    static fromJson(json: any): PutRecordsResponseRecord {\n        return new PutRecordsResponseRecord(json.SequenceNumber, json.ShardId);\n    }\n}\n\n\n// Request class for GetRecords API\nexport interface GetRecordsRequest {\n    ShardIterator: string;\n    Limit?: number;\n}\n\n// Response class for GetRecords API\nexport class GetRecordsResponse {\n    NextShardIterator: string;\n    Records: GetRecordsResponseRecord[];\n\n    constructor(nextShardIterator: string, records: GetRecordsResponseRecord[]) {\n        this.NextShardIterator = nextShardIterator;\n        this.Records = records;\n    }\n\n    static fromJson(json: any): GetRecordsResponse {\n        const nextShardIterator = json.NextShardIterator;\n        const records = json.Records.map(record => GetRecordsResponseRecord.fromJson(record));\n        return new GetRecordsResponse(nextShardIterator, records);\n    }\n}\n\nclass GetRecordsResponseRecord {\n    Data: string | ArrayBuffer;\n    PartitionKey: string;\n    SequenceNumber: string;\n\n    constructor(data: string | ArrayBuffer, partitionKey: string, sequenceNumber: string) {\n        this.Data = data;\n        this.PartitionKey = partitionKey;\n        this.SequenceNumber = sequenceNumber;\n    }\n\n    static fromJson(json: any): GetRecordsResponseRecord {\n        return new GetRecordsResponseRecord(json.Data, json.PartitionKey, json.SequenceNumber);\n    }\n}\n\n// Request class for ListShards API\ninterface ListShardsRequest {\n    StreamName: string;\n    NextToken: string;\n    MaxResults: number;\n}\n\n// Response class for ListShards API\nexport class ListShardsResponse {\n    Shards: ListShardsResponseShard[];\n    NextToken?: string;\n\n    constructor(shards: ListShardsResponseShard[], nextToken?: string) {\n        this.Shards = shards;\n        this.NextToken = nextToken;\n    }\n\n    static fromJson(json: any): ListShardsResponse {\n        const shards = json.Shards.map(shard => ListShardsResponseShard.fromJson(shard));\n        const nextToken = json.NextToken;\n        return new ListShardsResponse(shards, nextToken);\n    }\n}\n\nexport class ListShardsResponseShard {\n    ShardId: string;\n    ParentShardId?: string;\n    AdjacentParentShardId?: string;\n    HashKeyRange: {\n        StartingHashKey: string;\n        EndingHashKey: string;\n    };\n    SequenceNumberRange: {\n        StartingSequenceNumber: string;\n        EndingSequenceNumber?: string;\n    };\n\n    constructor(\n        shardId: string,\n        hashKeyRange: { StartingHashKey: string; EndingHashKey: string },\n        sequenceNumberRange: { StartingSequenceNumber: string; EndingSequenceNumber?: string },\n        parentShardId?: string,\n        adjacentParentShardId?: string\n    ) {\n        this.ShardId = shardId;\n        this.ParentShardId = parentShardId;\n        this.AdjacentParentShardId = adjacentParentShardId;\n        this.HashKeyRange = hashKeyRange;\n        this.SequenceNumberRange = sequenceNumberRange;\n    }\n\n    static fromJson(json: any): ListShardsResponseShard {\n        return new ListShardsResponseShard(\n            json.ShardId,\n            json.HashKeyRange,\n            json.SequenceNumberRange,\n            json.ParentShardId,\n            json.AdjacentParentShardId\n        );\n    }\n}\n\ninterface GetShardIteratorRequest {\n    StreamName: string;\n    ShardId: string;\n    ShardIteratorType: 'AT_SEQUENCE_NUMBER' | 'AFTER_SEQUENCE_NUMBER' | 'TRIM_HORIZON' | 'LATEST' | 'AT_TIMESTAMP';\n    StartingSequenceNumber?: string;\n    Timestamp?: number;\n}\n\nclass GetShardIteratorResponse {\n    ShardIterator: string;\n\n    constructor(shardIterator: string) {\n        this.ShardIterator = shardIterator;\n    }\n\n    static fromJson(json: any): GetShardIteratorResponse {\n        return new GetShardIteratorResponse(json.ShardIterator);\n    }\n}\n\n/* `KinesisServiceError` is a subclass of `AWSError` that adds an `operation` property */\nexport class KinesisServiceError extends AWSError {\n    operation: string\n\n    /**\n     * Constructs a KinesisServiceError\n     *\n     * @param  {string} message - human readable error message\n     * @param  {string} code - A unique short code representing the error that was emitted\n     * @param  {string} operation - Name of the failed Operation\n     */\n    constructor(message: string, code: string, operation: string) {\n        super(message, code)\n        this.name = 'KinesisServiceError'\n        this.operation = operation\n    }\n}\n\nconst hasKey = <T extends object>(obj: T, k: keyof any): k is keyof T =>\n    k in obj;","import { AWSConfig } from './config'\nimport { HTTPHeaders } from './http'\nimport { HTTPScheme } from './http'\n/**\n * Class allowing to build requests targeting AWS APIs\n *\n * This class is meant to be used as a base class for specific\n * services clients. See S3Client or SecretsManagerClient for\n * usage examples.\n */\nexport class AWSClient {\n    awsConfig: AWSConfig\n    serviceName: string\n\n    private _host?: string\n    private _scheme?: HTTPScheme\n    /**\n     * @param {AWSConfig} awsConfig - configuration attributes to use when interacting with AWS' APIs\n     * @param  {string} serviceName - name of the service to target.\n     * @param  {URIEncodingConfig} URIencodingConfig - configures how requests URIs should be encoded.\n     */\n    constructor(awsConfig: AWSConfig, serviceName: string) {\n        this.awsConfig = awsConfig\n        this.serviceName = serviceName\n    }\n\n    /**\n     * Property computing the URL to send the requests to when interacting with\n     * the specific AWS service the child class implements the functionalities of.\n     */\n    public get host() {\n        if (this._host == undefined) {\n          this._host = `${this.serviceName}.${this.awsConfig.region}.${this.awsConfig.endpoint}`\n        }\n        return this._host\n    }\n\n    public set host(host: string) {\n        this._host = host\n    }\n\n      /**\n     * Property computing the scheme to use http or https. Defaults to https as per AWSConfig Defaults\n     * the specific AWS service the child class implements the functionalities of.\n     */\n  \n    public get scheme() {\n\n      if (this._scheme == undefined) {\n        this._scheme = this.awsConfig.scheme;\n      }\n      return this._scheme\n    }\n  \n    // Validatiuon should be done by the type declaration \n    public set scheme(scheme: HTTPScheme) {\n      this._scheme = scheme\n  }\n\n}\n\n/**\n * Type alias representing the result of an AWSClient.buildRequest call\n */\nexport interface AWSRequest {\n    url: string\n    headers: HTTPHeaders\n}\n"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","AWSConfig","options","_classCallCheck","_defineProperty","region","InvalidAWSConfigError","concat","accessKeyId","length","secretAccessKey","this","undefined","sessionToken","scheme","endpoint","_createClass","__ENV","AWS_REGION","AWS_ACCESS_KEY_ID","AWS_SECRET_ACCESS_KEY","AWS_SESSION_TOKEN","_Error","_inherits","_super","_createSuper","message","_wrapNativeSuper","Error","require","AMZ_DATE_QUERY_PARAM","AMZ_SIGNATURE_QUERY_PARAM","AMZ_TOKEN_QUERY_PARAM","AMZ_CONTENT_SHA256_HEADER","AMZ_DATE_HEADER","toLowerCase","AMZ_SIGNATURE_HEADER","AMZ_TARGET_HEADER","AMZ_TOKEN_HEADER","AUTHORIZATION_HEADER","GENERATED_HEADERS","HOST_HEADER","ALWAYS_UNSIGNABLE_HEADERS","authorization","connection","expect","from","pragma","referer","te","trailer","upgrade","KEY_TYPE_IDENTIFIER","SIGNING_ALGORITHM_IDENTIFIER","AWSError","code","_this","_assertThisInitialized","name","xmlDocument","doc","parseHTML","find","text","SignatureV4","_ref","service","credentials","uriEscapePath","applyChecksum","request","_ref2","_ref2$signingDate","signingDate","Date","signingService","signingRegion","_ref2$unsignableHeade","unsignableHeaders","Set","_ref2$signableHeaders","signableHeaders","_formatDate","formatDate","longDate","shortDate","scope","constants","headers","hostname","_i","_Object$keys","keys","headerName","ArrayBuffer","isView","body","buffer","payloadHash","computePayloadHash","soughtHeader","hasHeader","canonicalHeaders","computeCanonicalHeaders","signature","calculateSignature","deriveSigningKey","createCanonicalRequest","sort","join","url","protocol","path","query","serializeQueryParameters","_objectSpread","originalRequest","arguments","_options$signingDate","_options$expiresIn","expiresIn","unhoistableHeaders","_formatDate2","InvalidSignatureError","moveHeadersToQuery","toString","signingKey","canonicalRequest","sortedHeaders","sortedCanonicalHeaders","map","signedHeaders","method","computeCanonicalURI","computeCanonicalQuerystring","credentialScope","hashedCanonicalRequest","crypto","stringToSign","createStringToSign","kSecret","kDate","kRegion","kService","_ref3","_step","normalizedURISegments","_iterator","_createForOfIteratorHelper","split","s","n","done","URISegment","pop","push","err","e","f","leading","startsWith","URI","trailing","endsWith","normalizedURI","encodeURIComponent","replace","_ref4","_step2","_ref4$query","serialized","_loop","escapeURI","Array","isArray","slice","reduce","encoded","_iterator2","filter","_ref5","_step3","_iterator3","canonicalHeaderName","has","trim","_ref6","requestCopy","JSON","parse","stringify","_requestCopy$query","_i2","_Object$keys2","_options$unhoistableH","lowerCaseName","ignoreKeys","_step4","_loop2","includes","_iterator4","_AWSError","c","charCodeAt","toUpperCase","date","time","Number","toDate","toISOString","KinesisClient","_AWSClient","awsConfig","serviceVersion","serviceName","commonHeaders","_possibleConstructorReturn","Proxy","client","target","hasKey","RequestOperation","apply","signedRequest","sign","host","res","http","_handle_error","console","log","operation","response","errorCode","error_code","error","json","errorMessage","Message","__type","KinesisServiceError","ListStreamsResponse","fromJson","PutRecordsResponse","GetRecordsResponse","ListShardsResponse","GetShardIteratorResponse","AWSClient","_host","set","_scheme","StreamSummary","StreamARN","StreamCreationTimestamp","StreamMode","StreamName","StreamStatus","StreamModeDetails","summary","streammode","HasMoreStreams","NextToken","StreamNames","StreamSummaries","result","String","failedRecordCount","records","FailedRecordCount","Records","record","PutRecordsResponseRecord","sequenceNumber","shardId","SequenceNumber","ShardId","nextShardIterator","NextShardIterator","GetRecordsResponseRecord","data","partitionKey","Data","PartitionKey","shards","nextToken","Shards","shard","ListShardsResponseShard","hashKeyRange","sequenceNumberRange","parentShardId","adjacentParentShardId","ParentShardId","AdjacentParentShardId","HashKeyRange","SequenceNumberRange","shardIterator","ShardIterator","_super2","_this2","k"],"sourceRoot":""}